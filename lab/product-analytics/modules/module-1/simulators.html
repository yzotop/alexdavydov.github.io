<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Симуляторы — Модуль 1. Продукт как система</title>
    <link rel="stylesheet" href="../../assets/style.css">
    <style>
        /* Simulator containers */
        .sim-interactive {
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            padding: 2rem;
            margin-bottom: 2.5rem;
            background: #fafafa;
        }
        .sim-interactive .sim-title {
            font-size: 1.2rem;
        }
        .sim-interactive .sim-description {
            max-width: 600px;
        }

        /* Controls */
        .sim-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.25rem;
            margin: 1.5rem 0;
            max-width: 500px;
        }
        .sim-control-group {
            display: flex;
            flex-direction: column;
            gap: 0.35rem;
        }
        .sim-control-label {
            font-size: 0.8rem;
            color: #666;
            font-weight: 500;
        }
        .sim-control-value {
            font-size: 0.75rem;
            color: #999;
            font-variant-numeric: tabular-nums;
        }
        .sim-control-group input[type="range"] {
            width: 100%;
            accent-color: #1a1a1a;
        }

        /* Toggle */
        .sim-toggle-group {
            grid-column: 1 / -1;
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }
        .sim-toggle-btn {
            padding: 0.4rem 0.9rem;
            font-size: 0.8rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            background: #fff;
            color: #666;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
        }
        .sim-toggle-btn.active {
            background: #1a1a1a;
            color: #fff;
            border-color: #1a1a1a;
        }

        /* Chart */
        .sim-chart-wrap {
            position: relative;
            width: 100%;
            max-width: 600px;
            height: 280px;
            margin: 1.5rem 0 1rem 0;
        }
        .sim-chart-wrap canvas {
            width: 100%;
            height: 100%;
        }
        .sim-chart-legend {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
            font-size: 0.75rem;
            color: #666;
        }
        .sim-chart-legend span::before {
            content: '';
            display: inline-block;
            width: 12px;
            height: 2px;
            margin-right: 0.35rem;
            vertical-align: middle;
        }
        .legend-metric::before { background: #1a1a1a; }
        .legend-baseline::before { background: #ccc; }

        .sim-reading {
            font-size: 0.85rem;
            line-height: 1.5;
            color: #666;
            font-style: italic;
            margin-top: 1rem;
            max-width: 600px;
        }

        /* Impact map */
        .impact-map {
            position: relative;
            max-width: 600px;
            margin: 1.5rem 0;
        }
        .impact-triggers {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        .impact-trigger {
            padding: 0.45rem 0.9rem;
            font-size: 0.85rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            background: #fff;
            color: #1a1a1a;
            cursor: pointer;
            transition: all 0.15s ease;
            font-family: inherit;
        }
        .impact-trigger:hover {
            border-color: #999;
        }
        .impact-trigger.active {
            background: #1a1a1a;
            color: #fff;
            border-color: #1a1a1a;
        }
        .impact-metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.75rem;
        }
        .impact-metric {
            padding: 0.75rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            background: #fff;
            transition: all 0.3s ease;
        }
        .impact-metric.highlighted {
            border-color: #1a1a1a;
            background: #f5f5f0;
        }
        .impact-metric.highlighted.negative {
            border-color: #c0a0a0;
            background: #faf5f5;
        }
        .impact-metric-name {
            font-size: 0.8rem;
            font-weight: 500;
            color: #1a1a1a;
            margin-bottom: 0.2rem;
        }
        .impact-metric-effect {
            font-size: 0.7rem;
            color: #999;
            opacity: 0;
            transition: opacity 0.3s ease;
            line-height: 1.3;
        }
        .impact-metric.highlighted .impact-metric-effect {
            opacity: 1;
            color: #666;
        }

        @media (max-width: 600px) {
            .sim-controls {
                grid-template-columns: 1fr;
            }
            .impact-metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="breadcrumbs">
            <a href="../../index.html">Курс</a> / <a href="./index.html">Модуль 1</a> / Симуляторы
        </div>

        <div class="nav-links">
            <a href="./index.html">Модуль</a>
            <a href="./practice.html">Практика</a>
            <a href="./simulators.html" class="active">Симуляторы</a>
        </div>

        <h1>Симуляторы</h1>
        <p class="subtitle">Модуль 1. Продукт как система</p>

        <!-- Simulator 1: Feedback Loop -->
        <div class="sim-interactive" id="feedback-sim">
            <div class="sim-title">Симулятор петель обратной связи</div>
            <div class="sim-description">
                Как ведёт себя метрика, если воздействие запускает петлю — усиливающую или балансирующую? Попробуйте менять параметры и наблюдать за динамикой.
            </div>

            <div class="sim-controls">
                <div class="sim-control-group">
                    <label class="sim-control-label">Интенсивность воздействия</label>
                    <input type="range" id="intensity" min="1" max="10" value="5" step="1">
                    <span class="sim-control-value" id="intensity-val">5</span>
                </div>
                <div class="sim-control-group">
                    <label class="sim-control-label">Лаг отклика (периоды)</label>
                    <input type="range" id="lag" min="0" max="8" value="2" step="1">
                    <span class="sim-control-value" id="lag-val">2</span>
                </div>
                <div class="sim-toggle-group">
                    <button class="sim-toggle-btn active" id="btn-reinforcing">Усиливающая</button>
                    <button class="sim-toggle-btn" id="btn-balancing">Балансирующая</button>
                </div>
            </div>

            <div class="sim-chart-legend">
                <span class="legend-metric">Метрика</span>
                <span class="legend-baseline">Базовый уровень</span>
            </div>
            <div class="sim-chart-wrap">
                <canvas id="loop-chart"></canvas>
            </div>
            <div class="sim-reading" id="loop-reading">
                Усиливающая петля с интенсивностью 5 и лагом 2: метрика растёт с ускорением — каждый цикл добавляет больше, чем предыдущий.
            </div>
        </div>

        <!-- Simulator 2: Impact Map -->
        <div class="sim-interactive" id="impact-sim">
            <div class="sim-title">Карта последствий воздействия</div>
            <div class="sim-description">
                Выберите воздействие — и посмотрите, какие метрики оно затрагивает. Не все эффекты очевидны, не все — положительны.
            </div>

            <div class="impact-map">
                <div class="impact-triggers">
                    <button class="impact-trigger" data-trigger="promo">Бесплатная доставка</button>
                    <button class="impact-trigger" data-trigger="push">Push-напоминания</button>
                    <button class="impact-trigger" data-trigger="autoplay">Автоплей контента</button>
                    <button class="impact-trigger" data-trigger="onboarding">Ускорение онбординга</button>
                </div>

                <div class="impact-metrics-grid" id="metrics-grid">
                    <div class="impact-metric" data-metric="registrations">
                        <div class="impact-metric-name">Регистрации</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="retention">
                        <div class="impact-metric-name">Retention</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="avg-check">
                        <div class="impact-metric-name">Средний чек</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="session">
                        <div class="impact-metric-name">Время сессии</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="dau">
                        <div class="impact-metric-name">DAU</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="ltv">
                        <div class="impact-metric-name">LTV</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="cac">
                        <div class="impact-metric-name">CAC</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="churn">
                        <div class="impact-metric-name">Churn rate</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                    <div class="impact-metric" data-metric="conversion">
                        <div class="impact-metric-name">Конверсия</div>
                        <div class="impact-metric-effect"></div>
                    </div>
                </div>
            </div>

            <div class="sim-reading" id="impact-reading" style="min-height: 2.5em;">
                Выберите воздействие, чтобы увидеть связанные метрики.
            </div>
        </div>

        <nav class="module-nav">
            <a href="./index.html">← К модулю</a>
            <a href="../../index.html">К курсу</a>
            <a href="./practice.html">Практика →</a>
        </nav>
    </div>

    <script>
    /* ==============================
       Simulator 1: Feedback Loop
       ============================== */
    (function() {
        const canvas = document.getElementById('loop-chart');
        const ctx = canvas.getContext('2d');
        const intensityEl = document.getElementById('intensity');
        const lagEl = document.getElementById('lag');
        const intensityVal = document.getElementById('intensity-val');
        const lagVal = document.getElementById('lag-val');
        const btnR = document.getElementById('btn-reinforcing');
        const btnB = document.getElementById('btn-balancing');
        const readingEl = document.getElementById('loop-reading');

        let loopType = 'reinforcing';
        const STEPS = 30;
        const BASELINE = 100;

        function setDPR() {
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        function simulate(intensity, lag, type) {
            const data = new Array(STEPS).fill(BASELINE);
            const gain = intensity * 0.04;

            for (let t = 1; t < STEPS; t++) {
                const feedbackIdx = t - lag;
                let feedback = 0;
                if (feedbackIdx >= 1) {
                    const delta = data[feedbackIdx] - BASELINE;
                    feedback = delta * gain;
                }

                if (type === 'reinforcing') {
                    data[t] = data[t - 1] + intensity * 0.8 + feedback;
                } else {
                    const target = BASELINE + intensity * 12;
                    const diff = target - data[t - 1];
                    const approach = diff * (0.15 + gain * 0.3);
                    const dampening = feedback > 0 ? -feedback * 0.3 : 0;
                    data[t] = data[t - 1] + approach + dampening;
                }
            }
            return data;
        }

        function draw() {
            setDPR();
            const rect = canvas.getBoundingClientRect();
            const W = rect.width;
            const H = rect.height;
            const intensity = +intensityEl.value;
            const lag = +lagEl.value;

            const data = simulate(intensity, lag, loopType);
            const maxV = Math.max(...data) * 1.1;
            const minV = Math.min(BASELINE * 0.8, Math.min(...data) * 0.95);

            ctx.clearRect(0, 0, W, H);

            // Grid
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = H * 0.05 + (H * 0.9) * (i / 4);
                ctx.beginPath();
                ctx.moveTo(40, y);
                ctx.lineTo(W - 10, y);
                ctx.stroke();
            }

            // Baseline
            const baseY = H * 0.05 + (H * 0.9) * (1 - (BASELINE - minV) / (maxV - minV));
            ctx.strokeStyle = '#ccc';
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(40, baseY);
            ctx.lineTo(W - 10, baseY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Y-axis labels
            ctx.fillStyle = '#999';
            ctx.font = '10px -apple-system, sans-serif';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 4; i++) {
                const y = H * 0.05 + (H * 0.9) * (i / 4);
                const val = maxV - (maxV - minV) * (i / 4);
                ctx.fillText(Math.round(val), 35, y + 3);
            }

            // X-axis labels
            ctx.textAlign = 'center';
            for (let i = 0; i < STEPS; i += 5) {
                const x = 40 + (W - 50) * (i / (STEPS - 1));
                ctx.fillText(i, x, H - 2);
            }

            // Data line
            ctx.strokeStyle = '#1a1a1a';
            ctx.lineWidth = 2;
            ctx.lineJoin = 'round';
            ctx.beginPath();
            for (let i = 0; i < STEPS; i++) {
                const x = 40 + (W - 50) * (i / (STEPS - 1));
                const y = H * 0.05 + (H * 0.9) * (1 - (data[i] - minV) / (maxV - minV));
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Lag marker
            if (lag > 0 && lag < STEPS) {
                const lx = 40 + (W - 50) * (lag / (STEPS - 1));
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.setLineDash([2, 3]);
                ctx.beginPath();
                ctx.moveTo(lx, H * 0.05);
                ctx.lineTo(lx, H * 0.95);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#bbb';
                ctx.font = '9px -apple-system, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('лаг', lx, H * 0.03 + 8);
            }

            updateReading(intensity, lag);
        }

        function updateReading(intensity, lag) {
            const typeLabel = loopType === 'reinforcing' ? 'Усиливающая' : 'Балансирующая';
            let text;
            if (loopType === 'reinforcing') {
                if (lag <= 1) {
                    text = `${typeLabel} петля с быстрым откликом: метрика разгоняется почти без задержки. Чем выше интенсивность — тем круче рост.`;
                } else if (lag <= 4) {
                    text = `${typeLabel} петля с лагом ${lag}: рост начинается плавно, затем ускоряется. Задержка скрывает масштаб будущего эффекта.`;
                } else {
                    text = `${typeLabel} петля с длинным лагом (${lag}): эффект долго не виден, затем метрика начинает расти — к этому моменту отменить воздействие уже сложно.`;
                }
            } else {
                if (lag <= 1) {
                    text = `${typeLabel} петля с быстрым откликом: метрика быстро стремится к новому уровню и стабилизируется.`;
                } else if (lag <= 4) {
                    text = `${typeLabel} петля с лагом ${lag}: метрика выходит на плато с небольшими колебаниями. Система адаптируется.`;
                } else {
                    text = `${typeLabel} петля с длинным лагом (${lag}): метрика долго растёт, прежде чем система начинает компенсировать — возможны ложные выводы в начале.`;
                }
            }
            readingEl.textContent = text;
        }

        intensityEl.addEventListener('input', function() {
            intensityVal.textContent = this.value;
            draw();
        });
        lagEl.addEventListener('input', function() {
            lagVal.textContent = this.value;
            draw();
        });
        btnR.addEventListener('click', function() {
            loopType = 'reinforcing';
            btnR.classList.add('active');
            btnB.classList.remove('active');
            draw();
        });
        btnB.addEventListener('click', function() {
            loopType = 'balancing';
            btnB.classList.add('active');
            btnR.classList.remove('active');
            draw();
        });

        window.addEventListener('resize', draw);
        draw();
    })();

    /* ==============================
       Simulator 2: Impact Map
       ============================== */
    (function() {
        const impactData = {
            promo: {
                label: 'Бесплатная доставка',
                reading: 'Бесплатная доставка привлекает объём, но меняет состав аудитории. Краткосрочный сигнал позитивный, но unit-экономика ухудшается — эффект виден только через 2–3 месяца.',
                metrics: {
                    registrations: { text: 'рост +40%', negative: false },
                    retention: { text: 'падение у промо-когорты', negative: true },
                    'avg-check': { text: 'снижение на 15–20%', negative: true },
                    dau: { text: 'кратковременный рост', negative: false },
                    ltv: { text: 'снижение для новой когорты', negative: true },
                    cac: { text: 'снижение (больше регистраций)', negative: false },
                    churn: { text: 'рост после окончания промо', negative: true },
                    conversion: { text: 'рост первого заказа', negative: false }
                }
            },
            push: {
                label: 'Push-напоминания',
                reading: 'Push-уведомления поднимают DAU, но при ежедневной частоте быстро теряют эффект. Канал «выгорает» — пользователи отключают уведомления, и вернуть их сложнее.',
                metrics: {
                    dau: { text: 'рост в первые недели', negative: false },
                    retention: { text: 'не растёт или падает', negative: true },
                    session: { text: 'без значимого роста', negative: false },
                    churn: { text: 'рост у раздражённого сегмента', negative: true }
                }
            },
            autoplay: {
                label: 'Автоплей контента',
                reading: 'Автоплей увеличивает время сессии, но размывает осознанность потребления. У части аудитории рост сессии ведёт не к лояльности, а к усталости и оттоку.',
                metrics: {
                    session: { text: 'рост +20–30%', negative: false },
                    dau: { text: 'без изменений', negative: false },
                    churn: { text: 'рост через 2–3 недели', negative: true },
                    retention: { text: 'снижение у интенсивных пользователей', negative: true }
                }
            },
            onboarding: {
                label: 'Ускорение онбординга',
                reading: 'Короткий онбординг снижает барьер входа, но не помогает понять ценность продукта. Конверсия в первую сессию растёт, а в платящего — нет.',
                metrics: {
                    conversion: { text: 'рост первой сессии', negative: false },
                    registrations: { text: 'небольшой рост', negative: false },
                    retention: { text: 'без изменений', negative: false },
                    ltv: { text: 'без изменений', negative: false }
                }
            }
        };

        const triggers = document.querySelectorAll('.impact-trigger');
        const metricsGrid = document.getElementById('metrics-grid');
        const metrics = metricsGrid.querySelectorAll('.impact-metric');
        const readingEl = document.getElementById('impact-reading');
        let activeTrigger = null;

        triggers.forEach(function(btn) {
            btn.addEventListener('click', function() {
                const key = this.dataset.trigger;

                // Toggle off
                if (activeTrigger === key) {
                    activeTrigger = null;
                    triggers.forEach(function(b) { b.classList.remove('active'); });
                    resetMetrics();
                    readingEl.textContent = 'Выберите воздействие, чтобы увидеть связанные метрики.';
                    return;
                }

                activeTrigger = key;
                triggers.forEach(function(b) { b.classList.remove('active'); });
                this.classList.add('active');

                const data = impactData[key];
                resetMetrics();

                metrics.forEach(function(el) {
                    const mKey = el.dataset.metric;
                    if (data.metrics[mKey]) {
                        el.classList.add('highlighted');
                        if (data.metrics[mKey].negative) {
                            el.classList.add('negative');
                        }
                        el.querySelector('.impact-metric-effect').textContent = data.metrics[mKey].text;
                    }
                });

                readingEl.textContent = data.reading;
            });
        });

        function resetMetrics() {
            metrics.forEach(function(el) {
                el.classList.remove('highlighted', 'negative');
                el.querySelector('.impact-metric-effect').textContent = '';
            });
        }
    })();
    </script>
</body>
</html>
