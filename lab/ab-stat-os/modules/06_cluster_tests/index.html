<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Модуль 6. Кластерные эксперименты — Статистика A/B-тестирования</title>
    <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
    <div class="container">
        <div class="breadcrumbs">
            <a href="../../../../courses/index.html">Все курсы</a> /
            <a href="../../index.html">Статистика A/B-тестирования</a> / Модуль 6
        </div>

        <div class="nav-links">
            <a href="./index.html" class="active">Модуль</a>
            <a href="./practice.html">Практика</a>
            <a href="./simulators.html">Симуляторы</a>
        </div>

        <h1>Модуль 6. Кластерные эксперименты</h1>

        <!-- Section 1 -->
        <section class="section">
            <h2>1. Почему user-level рандомизация ломается</h2>

            <p>
                В идеальном мире мы всегда рандомизируем пользователей по <code>user_id</code> и считаем метрики на уровне пользователя. На практике есть много ситуаций, где такой подход нарушает SUTVA и даёт завышенную значимость. В этих кейсах приходится переходить к кластерной рандомизации.
            </p>

            <h3>Гео-эксперименты</h3>
            <p>
                Вы тестируете изменение цены доставки в разных городах. Формально можно рандомизировать по пользователям: часть жителей города A попадает в тест, часть — в контроль. Но в реальности пользователи живут в общем ценовом окружении: обсуждают цены с друзьями, сравнивают с конкурентами, видят наружную рекламу.
            </p>
            <p>
                Если внутри одного города часть людей платит по старой цене, а часть по новой, возникает сильный <em>spillover</em>: поведение пользователей зависит не только от их treatment-статуса, но и от того, что происходит вокруг. Гораздо естественнее рандомизировать <strong>целиком города</strong>, чтобы все жители одного города жили в одной ценовой реальности.
            </p>

            <h3>Курьерские зоны</h3>
            <p>
                Логистическая команда тестирует новый алгоритм распределения заказов по курьерам. Если рандомизировать по заказам, один и тот же курьер в одной смене может обслуживать и тестовые, и контрольные заказы. Тогда treatment для части заказов изменяет загрузку курьеров для всех остальных заказов.
            </p>
            <p>
                В результате время доставки заказов из «контроля» зависит от того, сколько тестовых заказов попало в ту же курьерскую зону. Правильнее рандомизировать <strong>зоны или курьеров</strong> целиком, чтобы вся нагрузка внутри кластера менялась согласованно.
            </p>

            <h3>Школы, магазины, регионы</h3>
            <p>
                Образовательный продукт запускает новый формат уроков. Если рандомизировать по ученикам внутри класса, учитель будет одновременно вести старую и новую программу, ученики будут обсуждать разные версии, домашние задания перемешаются — сильнейшая интерференция.
            </p>
            <p>
                Похожая картина в ритейле: промо-материалы, выкладка товаров, обучение персонала — всё это делается на уровне магазина или региона, а не отдельного покупателя. Поэтому рандомизировать имеет смысл <strong>классы, школы, магазины, регионы</strong>, а не индивидуальных людей внутри них.
            </p>

            <h3>Network effects и spillover</h3>
            <p>
                В социальных сетях, маркетплейсах и мессенджерах пользователи связаны графом. Treatment для одного пользователя (новый формат постов, другой алгоритм ранжирования, новая схема комиссий для продавцов) почти всегда меняет окружение других пользователей.
            </p>
            <p>
                Если рандомизировать по user_id в такой среде, эффект «перетекает» из теста в контроль: друзья, коллеги, продавцы и покупатели одновременно участвуют в эксперименте с разными статусами. Это систематически нарушает SUTVA и делает наивную интерпретацию эффекта некорректной.
            </p>

            <div class="callout">
                <p><strong>Правило:</strong> как только между пользователями появляются сильные взаимодействия (география, логистика, классы, социалка, маркетплейс) — задумывайтесь о <strong>кластерной рандомизации</strong>, даже если кажется, что user-level split проще технически.</p>
            </div>
        </section>

        <!-- Section 2 -->
        <section class="section">
            <h2>2. Единица рандомизации ≠ единица анализа</h2>

            <h3>Что это значит</h3>
            <p>
                <strong>Единица рандомизации</strong> — объект, которому назначается treatment (город, магазин, курьерская зона, класс, пользователь). <strong>Единица анализа</strong> — объект, на уровне которого вы считаете метрику и строите статистический тест (пользователь, заказ, сессия, город).
            </p>
            <p>
                В простом user-level A/B-тесте эти уровни совпадают: мы рандомизируем по пользователям и считаем, например, выручку на пользователя. В кластерных экспериментах часто рандомизация и анализ оказываются на разных уровнях, и именно здесь начинаются типичные ошибки.
            </p>

            <h3>Почему несовпадение опасно</h3>
            <p>
                Представьте гео-эксперимент: 20 городов, в 10 подняли цены (тест), 10 оставили как есть (контроль). Всего 1&nbsp;000&nbsp;000 пользователей. Аналитик выгружает все чеки пользователей и запускает обычный t-test по 1M наблюдений. Формально N огромный, p-value почти нулевой.
            </p>
            <p>
                Но реальный источник вариации — различия между 20 городами, а не между миллионом пользователей. Эффективный размер выборки &asymp; 20, а не 1M. Если правильно учесть кластерную структуру, типичная <strong>ошибка первого рода</strong> (ложноположительные) может вырасти до 30–50% вместо ожидаемых 5%.
            </p>

            <h3>Пример CTR в маркетплейсе</h3>
            <p>
                Маркетплейс тестирует новый алгоритм ранжирования по кластерам «продавец» или «регион», но метрику считает на уровне показов (impressions) или кликов по товарам. Показы одного и того же продавца или региона внутри кластера сильно скоррелированы.
            </p>
            <p>
                Если запустить наивный t-test по показам, он будет считать, что каждый показ — независимое наблюдение, и сильно занизит дисперсию. Правильная единица анализа здесь — <strong>кластер (продавец, регион, магазин)</strong> с агрегированной метрикой, либо использование cluster-robust стандартных ошибок.
            </p>
        </section>

        <!-- Section 3 -->
        <section class="section">
            <h2>3. ICC (Intraclass Correlation)</h2>

            <h3>Что измеряет ICC</h3>
            <p>
                ICC (Intraclass Correlation Coefficient) показывает, какую долю общей вариации метрики объясняет принадлежность к одному и тому же кластеру. Это число от 0 до 1.
            </p>
            <ul>
                <li><strong>ICC = 0</strong> — кластеры ничего не объясняют. Пользователи внутри одного города/магазина ведут себя так же разнообразно, как и пользователи в разных.</li>
                <li><strong>ICC = 1</strong> — все пользователи внутри кластера имеют одинаковое значение метрики, а вся вариация идёт только между кластерами.</li>
            </ul>

            <h3>Интуиция на примере 10 городов</h3>
            <p>
                Допустим, у вас 10 городов по 100&nbsp;000 пользователей в каждом. Если ICC близок к нулю, то пользователи внутри одного города не более похожи друг на друга, чем пользователи из разных городов — каждый новый пользователь добавляет почти независимую информацию.
            </p>
            <p>
                Если ICC высок (например, из-за сильных региональных различий), то пользователи внутри одного города похожи: уровень спроса, сезонность, конкуренция. Тогда добавление ещё 10&nbsp;000 пользователей из того же города почти не увеличивает информацию — вы, по сути, всё ещё имеете «один и тот же» кластер.
            </p>

            <h3>Формальное определение</h3>
            <p>Пусть общая дисперсия метрики разбивается на компоненту «между кластерами» и «внутри кластеров»:</p>
            <div class="formula">
                ICC = σ²<sub>between</sub> / (σ²<sub>between</sub> + σ²<sub>within</sub>)
            </div>
            <p>
                Чем больше σ²<sub>between</sub> относительно общей дисперсии, тем выше ICC и тем сильнее кластерный эффект.
            </p>

            <h3>Типичные диапазоны ICC</h3>
            <table>
                <thead>
                    <tr>
                        <th>Контекст</th>
                        <th>ICC</th>
                    </tr>
                </thead>
                <tbody>
                    <tr><td>Города, одна страна</td><td>0.001–0.01</td></tr>
                    <tr><td>Магазины розничной сети</td><td>0.01–0.05</td></tr>
                    <tr><td>Классы в школе</td><td>0.05–0.20</td></tr>
                    <tr><td>Курьерские зоны</td><td>0.01–0.05</td></tr>
                    <tr><td>Районы мегаполиса</td><td>0.005–0.02</td></tr>
                </tbody>
            </table>
        </section>

        <!-- Section 4 -->
        <section class="section">
            <h2>4. Design Effect и Effective Sample Size</h2>

            <p>
                Кластерная структура данных раздувает дисперсию стандартных оценок. Эту инфляцию удобно описывать через <strong>design effect (DEFF)</strong> и эффективный размер выборки.
            </p>

            <div class="formula">
                DEFF = 1 + (m &minus; 1) &times; ICC
            </div>
            <div class="formula">
                n<sub>eff</sub> = n / DEFF
            </div>

            <p>
                Здесь m — средний размер кластера (число пользователей в городе/магазине/классе), n — общее число наблюдений (пользователей).
            </p>

            <h3>Числовой пример</h3>
            <p>
                Пусть у вас гео-эксперимент с 20 городами и 1&nbsp;000&nbsp;000 пользователями. Средний город даёт m = 50&nbsp;000 пользователей. Из pre-period оценили ICC &asymp; 0.05.
            </p>
            <p>
                Тогда:
            </p>
            <div class="formula">
                DEFF ≈ 1 + (50&nbsp;000 &minus; 1) × 0.05 ≈ 2501
            </div>
            <div class="formula">
                n<sub>eff</sub> = 1&nbsp;000&nbsp;000 / 2501 ≈ 400
            </div>
            <p>
                На практике из-за неоднородности кластеров и более реалистичных ICC часто говорят в терминах «эффективный N &asymp; число кластеров». В грубом приближении для множества реальных гео-экспериментов 1M пользователей в 20 городах превращаются в n<sub>eff</sub> ≈ 2000 и, в пределе, в те самые 20 точек на уровне городов.
            </p>

            <h3>Влияние на MDE и дизайн</h3>
            <p>
                Чем выше DEFF, тем меньше реальный power эксперимента и тем больше MDE (минимальный детектируемый эффект) при фиксированном горизонте. Эксперимент, который на бумаге выглядит сверхмощным при user-level предпосылках, в реальности может быть почти бессмысленным при кластерной структуре.
            </p>
            <div class="callout callout-warn">
                <p><strong>Правило:</strong> перед запуском гео- или кластерного эксперимента обязательно оцените ICC по pre-period и скорректируйте power-анализ через design effect. Никогда не планируйте мощность, игнорируя кластеры.</p>
            </div>
        </section>

        <!-- Section 5 -->
        <section class="section">
            <h2>5. Cluster-robust inference</h2>

            <p>
                Когда рандомизация или естественная структура данных кластерная, наивные стандартные ошибки (SE), которые предполагают независимость наблюдений, становятся некорректными. Есть два базовых подхода к корректному inference.
            </p>

            <h3>Подход A: агрегация до уровня кластера</h3>
            <p>
                Мы строим метрики на уровне кластера (город, магазин, класс), а не на уровне пользователя. Например, считаем средний чек по каждому городу, а затем сравниваем 10 тестовых городов с 10 контрольными с помощью t-test по 20 наблюдениям.
            </p>
            <p>
                Это простой и прозрачный подход: каждая точка в анализе соответствует независимому кластеру, предпосылка независимости становится куда более реалистичной.
            </p>

            <h3>Подход B: cluster-robust стандартные ошибки</h3>
            <p>
                Второй путь — использовать регрессию на уровне пользователей, но с кластерно-устойчивыми SE (cluster-robust / cluster-sandwich). В этом случае сами коэффициенты регрессии не меняются, но их стандартные ошибки пересчитываются с учётом внутрикластерной корреляции.
            </p>
            <p>
                При небольшом числе кластеров (например, 10–20 городов) обычные асимптотические формулы для cluster-robust SE ведут себя плохо. Тогда используют более аккуратные методы, например, <strong>wild cluster bootstrap</strong>, который даёт более корректные p-value и доверительные интервалы.
            </p>

            <h3>Какой подход когда использовать</h3>
            <table>
                <thead>
                    <tr>
                        <th>Ситуация</th>
                        <th>Рекомендуемый подход</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Мало кластеров (&lt; 30), агрегируемая метрика (средний чек, CR)</td>
                        <td>Агрегация до кластера + t-test / permutation test</td>
                    </tr>
                    <tr>
                        <td>Много кластеров (50+), нужны ковариаты и регрессия</td>
                        <td>Регрессия с cluster-robust SE по кластерам</td>
                    </tr>
                    <tr>
                        <td>Мало кластеров и сложная модель, важны точные p-value</td>
                        <td>Wild cluster bootstrap поверх регрессии</td>
                    </tr>
                    <tr>
                        <td>Гео-эксперимент с сильной неоднородностью кластеров</td>
                        <td>Агрегация + randomization inference (перестановки treatment между кластерами)</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Section 6 -->
        <section class="section">
            <h2>6. Практический чеклист</h2>

            <p>Перед запуском и анализом кластерного эксперимента пройдитесь по следующему чеклисту.</p>
            <ul>
                <li><strong>1. Определите кластеры.</strong> Явно опишите, что является кластером: город, магазин, курьерская зона, класс, продавец на маркетплейсе и т.п. Проверьте, что внутри кластера сильные взаимодействия, а между кластерами — относительно слабые.</li>
                <li><strong>2. Выберите единицу рандомизации.</strong> Убедитесь, что именно кластеры, а не отдельные пользователи, являются носителями treatment (см. обсуждение SUTVA и дизайна в модулях 1 и 5).</li>
                <li><strong>3. Согласуйте единицу анализа.</strong> Решите, будете ли вы агрегировать метрики до уровня кластера или использовать cluster-robust SE. Избегайте наивного user-level t-test, если рандомизация кластерная.</li>
                <li><strong>4. Оцените ICC по pre-period.</strong> Используйте исторические данные до эксперимента, чтобы прикинуть ICC и через design effect скорректировать power-анализ (связь с модулем 4 про MDE и мощность).</li>
                <li><strong>5. Проверьте баланс кластеров.</strong> По pre-period метрикам проверьте, не отличаются ли тестовые и контрольные кластеры по ключевым характеристикам (размер, GMV, рост, сезонность). При необходимости применяйте стратификацию или matching.</li>
                <li><strong>6. Выберите метод inference.</strong> Для малого числа кластеров используйте агрегацию и randomization inference; для большого — регрессию с cluster-robust SE или wild cluster bootstrap.</li>
                <li><strong>7. Задокументируйте допущения.</strong> В отчёте по эксперименту явно выпишите, что у вас кластерная рандомизация, какое у вас n<sub>eff</sub>, какой ICC и какой метод анализа вы применяли — это убережёт от неверных сравнений с user-level экспериментами из других модулей.</li>
            </ul>
        </section>

        <!-- Preview sections -->
        <section class="preview-section">
            <h2>Практика</h2>
            <ul class="preview-list">
                <li>14 задач на гео-эксперименты, design effect и ICC</li>
                <li>Выбор единицы рандомизации и анализа, малое число кластеров</li>
                <li>Spillover в соцсетях, маркетплейсах и школьных экспериментах</li>
            </ul>
            <a href="./practice.html" class="nav-card">Открыть практику</a>
        </section>

        <section class="preview-section">
            <h2>Симуляторы</h2>
            <ul class="preview-list">
                <li>Cluster Simulator — визуализация ICC, design effect и n<sub>eff</sub></li>
                <li>Сравнение наивного t-test и cluster-robust подходов</li>
                <li>Сценарии с разным числом кластеров и размером кластера</li>
            </ul>
            <a href="./simulators.html" class="nav-card">Открыть симуляторы</a>
        </section>

        <nav class="module-nav">
            <a href="../05_variance_reduction/index.html">← Предыдущий модуль</a>
            <a href="../../index.html">К курсу</a>
            <a href="../07_common_mistakes/index.html">Следующий модуль →</a>
        </nav>
    </div>
</body>
</html>
