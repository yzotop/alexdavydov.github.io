<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Metastability</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background-color: #ffffff;
            padding: 3rem 1rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1rem;
            font-weight: 400;
            color: #666;
            margin-bottom: 1rem;
            font-style: italic;
        }

        .caption {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 3rem;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 2rem;
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #1a1a1a;
        }

        .chart-container {
            margin-top: 3rem;
            background: #ffffff;
            padding: 2.5rem;
        }

        .mini-chart {
            margin-bottom: 2rem;
        }

        .chart-label {
            font-size: 11px;
            fill: #666;
            font-weight: 400;
            margin-bottom: 0.5rem;
        }

        .axis {
            font-size: 9px;
            fill: #999;
            font-weight: 400;
        }

        .axis .domain {
            display: none;
        }

        .axis .tick line {
            display: none;
        }

        .bar {
            fill: #2f3e4e;
            opacity: 0.8;
        }

        .basin-boundary {
            stroke: #e0e0e0;
            stroke-width: 1;
            stroke-dasharray: 2,2;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Equilibrium</a>
        <h1>Metastability</h1>
        <p class="subtitle">Stable—until it isn't.</p>
        <p class="caption">Two basins with rare transitions create long-lived pseudo-equilibria.</p>

        <div class="chart-container">
            <div id="charts"></div>
        </div>
    </div>

    <script>
        // States: 1..40
        const nStates = 40;
        const states = Array.from({ length: nStates }, (_, i) => i + 1);

        // Basin definitions
        const basinAEnd = 18;
        const barrierEnd = 22;
        const basinBStart = 23;

        // Helper function to check if state is in Basin A
        function inBasinA(state) {
            return state >= 1 && state <= basinAEnd;
        }

        // Helper function to check if state is in Barrier
        function inBarrier(state) {
            return state >= 19 && state <= barrierEnd;
        }

        // Helper function to check if state is in Basin B
        function inBasinB(state) {
            return state >= basinBStart && state <= nStates;
        }

        // Build transition matrix
        const matrix = [];
        for (let i = 0; i < nStates; i++) {
            const row = new Array(nStates).fill(0);
            const state = i + 1;

            // 1) Base local movement: i-1, i, i+1 with weights (0.25, 0.5, 0.25)
            if (state > 1) {
                row[i - 1] = 0.25;
            }
            row[i] = 0.5;
            if (state < nStates) {
                row[i + 1] = 0.25;
            }

            // 2) Basin reinforcement
            if (inBasinA(state)) {
                // Add +0.10 to transitions that keep you within Basin A
                // Prefer staying near current state
                if (state > 1 && inBasinA(state - 1)) {
                    row[i - 1] += 0.05; // staying in basin, moving left
                }
                if (inBasinA(state)) {
                    row[i] += 0.05; // staying in basin, staying put
                }
                if (state < nStates && inBasinA(state + 1)) {
                    row[i + 1] += 0.05; // staying in basin, moving right
                }
            } else if (inBasinB(state)) {
                // Add +0.10 to transitions that keep you within Basin B
                if (state > 1 && inBasinB(state - 1)) {
                    row[i - 1] += 0.05;
                }
                if (inBasinB(state)) {
                    row[i] += 0.05;
                }
                if (state < nStates && inBasinB(state + 1)) {
                    row[i + 1] += 0.05;
                }
            }

            // 3) Barrier resistance
            if (inBarrier(state)) {
                // Reduce staying probability slightly
                row[i] *= 0.8;
                // Allow drift toward nearest basin
                if (state <= 20) {
                    // Closer to A, shift weight toward i-1
                    if (state > 1) {
                        row[i - 1] += 0.1;
                    }
                } else {
                    // Closer to B, shift weight toward i+1
                    if (state < nStates) {
                        row[i + 1] += 0.1;
                    }
                }
            }

            // 4) Rare cross-basin transitions
            if (inBasinA(state)) {
                // Add +0.002 probability to go to state 30 (in Basin B)
                row[29] += 0.002; // state 30 is index 29
            } else if (inBasinB(state)) {
                // Add +0.002 probability to go to state 10 (in Basin A)
                row[9] += 0.002; // state 10 is index 9
            }

            // 5) Renormalize row to sum to 1
            const rowSum = row.reduce((a, b) => a + b, 0);
            if (rowSum > 0) {
                for (let j = 0; j < nStates; j++) {
                    row[j] = row[j] / rowSum;
                }
            }

            matrix.push(row);
        }

        // Initial distribution: all mass at state 10 (deep in Basin A)
        let v = new Array(nStates).fill(0);
        v[9] = 1; // state 10 is index 9

        // Compute distributions for t = 0, 2, 5, 10, 25, 50, 100, 200
        const snapshots = [0, 2, 5, 10, 25, 50, 100, 200];
        const distributions = [];

        let currentDist = [...v];
        for (let t = 0; t <= 200; t++) {
            if (snapshots.includes(t)) {
                distributions.push({ t, dist: [...currentDist] });
            }
            
            // Compute next distribution: v_{t+1} = v_t * P
            if (t < 200) {
                const nextDist = new Array(nStates).fill(0);
                for (let j = 0; j < nStates; j++) {
                    for (let i = 0; i < nStates; i++) {
                        nextDist[j] += currentDist[i] * matrix[i][j];
                    }
                }
                currentDist = nextDist;
            }
        }

        // Set up dimensions for mini charts
        const miniMargin = { top: 25, right: 10, bottom: 20, left: 10 };
        const miniWidth = 800 - miniMargin.left - miniMargin.right;
        const miniHeight = 70 - miniMargin.top - miniMargin.bottom;

        // Shared x-scale
        const xScale = d3.scaleBand()
            .domain(states)
            .range([0, miniWidth])
            .padding(0.05);

        // Shared y-scale (use max across all distributions)
        const maxProb = d3.max(distributions.map(d => d3.max(d.dist)));
        const yScale = d3.scaleLinear()
            .domain([0, maxProb])
            .nice()
            .range([miniHeight, 0]);

        // Create charts container
        const chartsContainer = d3.select("#charts");

        // Create each mini chart
        distributions.forEach(({ t, dist }, idx) => {
            const chartDiv = chartsContainer.append("div")
                .attr("class", "mini-chart");

            const svg = chartDiv.append("svg")
                .attr("width", miniWidth + miniMargin.left + miniMargin.right)
                .attr("height", miniHeight + miniMargin.top + miniMargin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);

            // Add label
            g.append("text")
                .attr("class", "chart-label")
                .attr("x", 0)
                .attr("y", -5)
                .text(`t = ${t}`);

            // Add basin boundary lines
            // Boundary between Basin A and Barrier: between state 18 and 19
            const boundary1X = xScale(18) + xScale.bandwidth();
            // Boundary between Barrier and Basin B: between state 22 and 23
            const boundary2X = xScale(22) + xScale.bandwidth();
            
            g.append("line")
                .attr("class", "basin-boundary")
                .attr("x1", boundary1X)
                .attr("x2", boundary1X)
                .attr("y1", 0)
                .attr("y2", miniHeight);

            g.append("line")
                .attr("class", "basin-boundary")
                .attr("x1", boundary2X)
                .attr("x2", boundary2X)
                .attr("y1", 0)
                .attr("y2", miniHeight);

            // Create bars
            g.selectAll(".bar")
                .data(dist)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", (d, i) => xScale(i + 1))
                .attr("width", xScale.bandwidth())
                .attr("y", d => yScale(d))
                .attr("height", d => miniHeight - yScale(d));

            // Add x-axis only on bottom-most chart
            if (idx === distributions.length - 1) {
                const xAxis = d3.axisBottom(xScale)
                    .ticks([1, 10, 20, 30, 40])
                    .tickSize(0)
                    .tickPadding(5);

                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${miniHeight})`)
                    .call(xAxis);
            }
        });
    </script>
</body>
</html>

