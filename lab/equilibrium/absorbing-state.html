<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Absorbing State</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background-color: #ffffff;
            padding: 3rem 1rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1rem;
            font-weight: 400;
            color: #666;
            margin-bottom: 1rem;
            font-style: italic;
        }

        .caption {
            font-size: 0.9rem;
            color: #888;
            margin-bottom: 3rem;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 2rem;
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #1a1a1a;
        }

        .chart-container {
            margin-top: 3rem;
            background: #ffffff;
            padding: 2.5rem;
        }

        .mini-chart {
            margin-bottom: 2rem;
        }

        .chart-label {
            font-size: 11px;
            fill: #666;
            font-weight: 400;
            margin-bottom: 0.5rem;
        }

        .axis {
            font-size: 9px;
            fill: #999;
            font-weight: 400;
        }

        .axis .domain {
            display: none;
        }

        .axis .tick line {
            display: none;
        }

        .bar {
            fill: #2f3e4e;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">← Back to Equilibrium</a>
        <h1>Absorbing State</h1>
        <p class="subtitle">Not all equilibria are reversible.</p>
        <p class="caption">Once entered, the absorbing state captures all mass.</p>

        <div class="chart-container">
            <div id="charts"></div>
        </div>
    </div>

    <script>
        // States: 1..20
        const nStates = 20;
        const states = Array.from({ length: nStates }, (_, i) => i + 1);

        // Build transition matrix
        const matrix = [];
        for (let i = 0; i < nStates; i++) {
            const row = new Array(nStates).fill(0);
            const state = i + 1;

            if (state === 20) {
                // State 20 is absorbing: P[20 → 20] = 1
                row[19] = 1;
            } else {
                // For states 1..19:
                // Move to i with probability 0.5
                row[i] = 0.5;
                
                // Move to i+1 with probability 0.35
                if (state < nStates) {
                    row[i + 1] = 0.35;
                }
                
                // Move to i-1 with probability 0.15
                if (state > 1) {
                    row[i - 1] = 0.15;
                } else {
                    // State 1: can't move left, add 0.15 to staying
                    row[i] = 0.65;
                }
            }

            // Ensure row is normalized (should already be, but double-check)
            const rowSum = row.reduce((a, b) => a + b, 0);
            if (rowSum > 0) {
                for (let j = 0; j < nStates; j++) {
                    row[j] = row[j] / rowSum;
                }
            }

            matrix.push(row);
        }

        // Initial distribution: all mass at state 8 (one-hot)
        let v = new Array(nStates).fill(0);
        v[7] = 1; // state 8 is index 7

        // Compute distributions for t = 0, 1, 2, 5, 10, 25
        const snapshots = [0, 1, 2, 5, 10, 25];
        const distributions = [];

        let currentDist = [...v];
        for (let t = 0; t <= 25; t++) {
            if (snapshots.includes(t)) {
                distributions.push({ t, dist: [...currentDist] });
            }
            
            // Compute next distribution: v_{t+1} = v_t * P
            if (t < 25) {
                const nextDist = new Array(nStates).fill(0);
                for (let j = 0; j < nStates; j++) {
                    for (let i = 0; i < nStates; i++) {
                        nextDist[j] += currentDist[i] * matrix[i][j];
                    }
                }
                currentDist = nextDist;
            }
        }

        // Set up dimensions for mini charts
        const miniMargin = { top: 25, right: 10, bottom: 20, left: 10 };
        const miniWidth = 800 - miniMargin.left - miniMargin.right;
        const miniHeight = 80 - miniMargin.top - miniMargin.bottom;

        // Shared x-scale
        const xScale = d3.scaleBand()
            .domain(states)
            .range([0, miniWidth])
            .padding(0.1);

        // Shared y-scale (use max across all distributions)
        const maxProb = d3.max(distributions.map(d => d3.max(d.dist)));
        const yScale = d3.scaleLinear()
            .domain([0, maxProb])
            .nice()
            .range([miniHeight, 0]);

        // Create charts container
        const chartsContainer = d3.select("#charts");

        // Create each mini chart
        distributions.forEach(({ t, dist }, idx) => {
            const chartDiv = chartsContainer.append("div")
                .attr("class", "mini-chart");

            const svg = chartDiv.append("svg")
                .attr("width", miniWidth + miniMargin.left + miniMargin.right)
                .attr("height", miniHeight + miniMargin.top + miniMargin.bottom);

            const g = svg.append("g")
                .attr("transform", `translate(${miniMargin.left},${miniMargin.top})`);

            // Add label
            g.append("text")
                .attr("class", "chart-label")
                .attr("x", 0)
                .attr("y", -5)
                .text(`t = ${t}`);

            // Create bars
            g.selectAll(".bar")
                .data(dist)
                .enter()
                .append("rect")
                .attr("class", "bar")
                .attr("x", (d, i) => xScale(i + 1))
                .attr("width", xScale.bandwidth())
                .attr("y", d => yScale(d))
                .attr("height", d => miniHeight - yScale(d));

            // Add x-axis only on bottom-most chart
            if (idx === distributions.length - 1) {
                const xAxis = d3.axisBottom(xScale)
                    .ticks(5)
                    .tickSize(0)
                    .tickPadding(5);

                g.append("g")
                    .attr("class", "axis")
                    .attr("transform", `translate(0,${miniHeight})`)
                    .call(xAxis);
            }
        });
    </script>
</body>
</html>

