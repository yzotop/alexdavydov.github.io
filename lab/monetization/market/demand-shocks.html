<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Шоки спроса</title>
        <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            background-color: #ffffff;
            padding: 3rem 1rem;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 300;
            margin-bottom: 0.5rem;
            color: #1a1a1a;
            letter-spacing: -0.02em;
        }

        .subtitle {
            font-size: 1.1rem;
            font-weight: 400;
            color: #666;
            margin-bottom: 3rem;
            font-style: italic;
        }

        .intro {
            max-width: 700px;
            margin-bottom: 4rem;
        }

        .intro p {
            font-size: 1rem;
            line-height: 1.7;
            color: #2c3e50;
            margin-bottom: 1.5rem;
        }

        .section {
            margin-bottom: 4rem;
        }

        .section-title {
            font-size: 0.85rem;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 2rem;
            font-weight: 500;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-bottom: 3rem;
        }

        @media (min-width: 600px) {
            .cards-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .card {
            padding: 1.25rem;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
            background: #fafafa;
        }

        .card-title {
            font-size: 1rem;
            font-weight: 500;
            color: #1a1a1a;
            margin-bottom: 0.75rem;
        }

        .card-item {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #2c3e50;
            margin-bottom: 0.75rem;
        }

        .card-item strong {
            color: #1a1a1a;
            font-weight: 500;
        }

        .card-item:last-child {
            margin-bottom: 0;
        }

        .card-list {
            list-style: none;
            padding-left: 0;
            margin-top: 0.75rem;
        }

        .card-list li {
            font-size: 0.9rem;
            line-height: 1.6;
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-left: 1.25rem;
            position: relative;
        }

        .card-list li:before {
            content: "•";
            position: absolute;
            left: 0;
            color: #999;
        }

        .chart-container {
            margin: 3rem 0;
            padding: 1.5rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
        }

        .chart-caption {
            font-size: 0.85rem;
            color: #888;
            font-style: italic;
            margin-top: 1rem;
            max-width: 700px;
        }

        .interactive-panel {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
            margin-bottom: 3rem;
            padding: 1.5rem;
            border: 1px solid #e8e8e8;
            border-radius: 6px;
        }

        @media (min-width: 900px) {
            .interactive-panel {
                grid-template-columns: 1fr 1.5fr;
            }
        }

        .controls-group {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-label {
            font-size: 0.9rem;
            color: #666;
        }

        .control-slider {
            width: 100%;
            margin-top: 0.5rem;
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .control-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .control-dropdown {
            width: 100%;
            padding: 0.5rem;
            margin-top: 0.5rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            font-size: 0.9rem;
            background: #ffffff;
            color: #2c3e50;
        }

        .control-value {
            font-size: 0.85rem;
            color: #999;
            margin-top: 0.25rem;
        }

        .output-panel {
            padding: 1.25rem;
            background: #fafafa;
            border-radius: 4px;
            font-size: 0.9rem;
            line-height: 1.7;
            color: #2c3e50;
        }

        .output-metric {
            padding: 0.75rem;
            background: #ffffff;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .output-metric-label {
            font-size: 0.85rem;
            color: #999;
            margin-bottom: 0.25rem;
        }

        .output-metric-value {
            font-size: 1.1rem;
            font-weight: 500;
            color: #1a1a1a;
        }

        .output-risk {
            margin-top: 1rem;
            padding: 0.75rem;
            background: #ffffff;
            border-left: 3px solid #1f2a37;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .output-risk.high {
            border-left-color: #cc0000;
        }

        .output-risk.medium {
            border-left-color: #ff9900;
        }

        .output-risk.low {
            border-left-color: #009900;
        }

        .rules-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 3rem;
            font-size: 0.9rem;
        }

        .rules-table th,
        .rules-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e8e8e8;
        }

        .rules-table th {
            background: #fafafa;
            font-weight: 500;
            color: #1a1a1a;
        }

        .rules-table td {
            color: #2c3e50;
        }

        .checklist {
            font-size: 0.95rem;
            line-height: 1.8;
            color: #2c3e50;
            padding-left: 1.25rem;
            margin-bottom: 3rem;
        }

        .checklist li {
            margin-bottom: 0.75rem;
        }

        .next-cards {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1rem;
            margin-bottom: 3rem;
        }

        @media (min-width: 600px) {
            .next-cards {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        .next-card {
            padding: 3rem 1rem;
            border: 1px solid #e8e8e8;
            border-radius: 4px;
            text-decoration: none;
            color: inherit;
            display: block;
            transition: border-color 0.2s ease;
        }

        .next-card:hover {
            border-color: #999;
        }

        .next-card-title {
            font-size: 0.95rem;
            font-weight: 500;
            color: #1a1a1a;
            margin-bottom: 0.5rem;
        }

        .next-card-text {
            font-size: 0.85rem;
            color: #666;
        }

        .back-link {
            display: inline-block;
            margin-bottom: 0.5rem;
            color: #666;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s ease;
        }

        .back-link:hover {
            color: #1a1a1a;
        }

        .back-link.secondary {
            font-size: 0.8rem;
            color: #999;
            margin-left: 1rem;
        }

        .footer {
            margin-top: 4rem;
            padding-top: 2rem;
            border-top: 1px solid #e8e8e8;
        }

        .footer-note {
            font-size: 0.85rem;
            color: #999;
            font-style: italic;
            margin-top: 1rem;
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 6px;
            background: #e8e8e8;
            border-radius: 3px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #1f2a37;
            border-radius: 50%;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #1f2a37;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../../../index.html" class="back-to-home">← На главную</a>

        
        <h1>Шоки спроса</h1>
        <p class="subtitle">Рынок двигается сам. Ваша задача — не принять фон за результат.</p>

        <div class="intro">
            <p>
                Сезонность — предсказуемые циклы (день недели, праздники, периоды активности). Спрос растёт и падает по известным паттернам: выходные отличаются от будних, праздники создают пики, лето отличается от зимы. Если вы не контролируете сезонность, любой эксперимент выглядит "эффектом": вы сравниваете понедельник с пятницей, или праздничную неделю с обычной.
            </p>
            <p>
                Шок — резкий сдвиг спроса или конкуренции. Внешнее событие (новость, изменение политики, конкурент запустил кампанию) меняет уровень спроса на дни или недели. Шок отличается от сезонности тем, что он разовый и непредсказуемый. Ошибка: приписывать рыночный эффект продуктовой фиче (и наоборот). Если CPM вырос после вашего изменения, но одновременно произошёл внешний шок, вы не можете знать, что было причиной.
            </p>
        </div>

        <div class="section">
            <div class="section-title">Сезонность vs Шок</div>
            <div class="cards-grid">
                <div class="card">
                    <div class="card-title">Сезонность</div>
                    <div class="card-item">
                        <strong>Как выглядит на графике:</strong> Регулярные циклы с предсказуемой периодичностью. День недели: пики в выходные или будни. Месяц: начало/конец месяца. Год: праздники, сезоны.
                    </div>
                    <div class="card-item">
                        <strong>Как проверять:</strong> Сравнение по одинаковым дням недели, неделям месяца, периодам года. Использование baseline модели с сезонными компонентами.
                    </div>
                    <ul class="card-list">
                        <li>Сравнивать понедельник с понедельником, а не с пятницей</li>
                        <li>Использовать WoW (week-over-week) сравнения</li>
                        <li>Строить baseline с учётом сезонных паттернов</li>
                    </ul>
                </div>

                <div class="card">
                    <div class="card-title">Шок</div>
                    <div class="card-item">
                        <strong>Как выглядит на графике:</strong> Резкий скачок или падение уровня, затем частичное восстановление или новый уровень. Не циклично, разово. Может быть синхронным по сегментам.
                    </div>
                    <div class="card-item">
                        <strong>Как проверять:</strong> Change-point detection (поиск точки разрыва). Контрольные сегменты (если шок внешний, он затронет все сегменты). Сверка с change log и внешними событиями.
                    </div>
                    <ul class="card-list">
                        <li>Искать change-point: где уровень резко изменился</li>
                        <li>Проверять синхронность по сегментам (внешний шок)</li>
                        <li>Сверять с change log и внешними событиями</li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">CPM/Volume/Revenue под сезонностью</div>
            <div class="chart-container">
                <svg id="seasonalityChart"></svg>
                <p class="chart-caption">Если вы не контролируете сезонность, любой эксперимент выглядит 'эффектом'.</p>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Шок и восстановление</div>
            <div class="chart-container">
                <svg id="shockChart"></svg>
                <p class="chart-caption">Шок меняет уровень. Сезонность меняет форму.</p>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Ошибка вывода: наивное сравнение vs нормализованное</div>
            <div class="chart-container">
                <svg id="comparisonChart"></svg>
                <p class="chart-caption">Сначала фон. Потом вывод.</p>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Собери фон</div>
            <div class="interactive-panel">
                <div class="controls-group">
                    <div class="control-group">
                        <label class="control-label">Сезонность</label>
                        <div class="control-checkbox">
                            <input type="checkbox" id="seasonalityCheck" checked>
                            <label for="seasonalityCheck" style="font-size: 0.9rem; color: #666;">Включить</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Амплитуда сезонности</label>
                        <input type="range" id="seasonalitySlider" class="control-slider" min="0" max="100" value="40">
                        <div class="control-value" id="seasonalityValue">40</div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Шок</label>
                        <div class="control-checkbox">
                            <input type="checkbox" id="shockCheck">
                            <label for="shockCheck" style="font-size: 0.9rem; color: #666;">Включить</label>
                        </div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Размер шока (%)</label>
                        <input type="range" id="shockSlider" class="control-slider" min="-50" max="50" value="20">
                        <div class="control-value" id="shockValue">+20</div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Шум</label>
                        <input type="range" id="noiseSlider" class="control-slider" min="0" max="100" value="10">
                        <div class="control-value" id="noiseValue">10</div>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Что вы 'измеряете'</label>
                        <select id="metricSelect" class="control-dropdown">
                            <option value="CPM">CPM</option>
                            <option value="Volume">Volume</option>
                            <option value="Revenue">Revenue</option>
                        </select>
                    </div>
                </div>
                <div class="output-panel" id="outputPanel">
                    <!-- Content will be populated by JS -->
                </div>
            </div>
        </div>

        <div class="section">
            <div class="section-title">Правила работы со шоками</div>
            <table class="rules-table">
                <thead>
                    <tr>
                        <th>Правило</th>
                        <th>Зачем</th>
                        <th>Типовая ошибка</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Сравнивать одинаковые дни недели</td>
                        <td>Исключить эффект дня недели (понедельник vs пятница)</td>
                        <td>Сравнивать понедельник с пятницей и думать, что это эффект</td>
                    </tr>
                    <tr>
                        <td>Держать стабильные окна</td>
                        <td>Окна сравнения должны быть одинаковой длины и структуры</td>
                        <td>Сравнивать 3 дня с 7 днями или праздничную неделю с обычной</td>
                    </tr>
                    <tr>
                        <td>Учитывать лаг</td>
                        <td>Рынок реагирует с задержкой, эффект может проявиться позже</td>
                        <td>Делать вывод сразу после изменения, не дожидаясь стабилизации</td>
                    </tr>
                    <tr>
                        <td>Иметь контрольный сегмент/поверхность</td>
                        <td>Контроль показывает, что происходит без вашего изменения</td>
                        <td>Считать, что изменения в контроле — это тоже эффект вашего изменения</td>
                    </tr>
                    <tr>
                        <td>Не менять несколько вещей одновременно</td>
                        <td>Нельзя понять, что именно вызвало эффект</td>
                        <td>Менять floor, caps и фичу одновременно, потом не знать причину</td>
                    </tr>
                    <tr>
                        <td>Фиксировать change log</td>
                        <td>Знать, когда и что менялось, чтобы не путать причины</td>
                        <td>Забывать, что менялось, и приписывать эффект не тому изменению</td>
                    </tr>
                    <tr>
                        <td>Смотреть распределения и хвосты</td>
                        <td>Среднее может скрывать изменения в хвостах или сегментах</td>
                        <td>Судить только по среднему, не видя, что хвосты или сегменты расходятся</td>
                    </tr>
                    <tr>
                        <td>Проверять price vs volume отдельно</td>
                        <td>Рост revenue может быть из-за price или volume, важно различать</td>
                        <td>Считать рост revenue успехом, не замечая, что volume упал</td>
                    </tr>
                    <tr>
                        <td>Не делать вывод по 1–2 дням</td>
                        <td>Короткие окна слишком шумные, легко ошибиться</td>
                        <td>Делать вывод по одному дню или двум дням, не дожидаясь стабилизации</td>
                    </tr>
                    <tr>
                        <td>Использовать baseline (ожидание) как референс</td>
                        <td>Baseline показывает, что было бы без изменения, с учётом сезонности</td>
                        <td>Сравнивать post с pre напрямую, не учитывая сезонность и тренд</td>
                    </tr>
                    <tr>
                        <td>Проверять синхронность по сегментам</td>
                        <td>Внешний шок затронет все сегменты, внутреннее изменение — только часть</td>
                        <td>Приписывать синхронный шок по всем сегментам внутреннему изменению</td>
                    </tr>
                    <tr>
                        <td>Сверять с внешними событиями</td>
                        <td>Праздники, новости, изменения политики влияют на спрос</td>
                        <td>Не знать о внешнем событии и приписывать его эффект своему изменению</td>
                    </tr>
                </tbody>
            </table>
        </div>

        <div class="section">
            <div class="section-title">Перед тем как сказать 'это эффект'</div>
            <ul class="checklist">
                <li>Есть ли сезонность? Проверь, не сравниваешь ли ты разные дни недели или периоды</li>
                <li>Был ли внешний шок? Проверь change log, внешние события, синхронность по сегментам</li>
                <li>Что с price vs volume? Разложи revenue на компоненты, не суди по одному числу</li>
                <li>Что с quality proxies? Рост CPM может быть компенсацией за падение quality</li>
                <li>Что с constraints/lost share? Ограничения могут маскироваться под рост спроса</li>
                <li>Что с сегментами? Среднее может скрывать проблемы в отдельных сегментах</li>
                <li>Что с хвостами? Распределение может меняться, даже если среднее стабильно</li>
                <li>Что с лагом? Эффект может проявиться позже, не делай вывод сразу</li>
                <li>Есть ли контрольный ряд? Контроль показывает, что происходит без твоего изменения</li>
                <li>Достаточно ли длина окна? Короткие окна слишком шумные, нужна стабилизация</li>
                <li>Есть ли возврат к базовой линии? Если эффект исчез, возможно, это был шок</li>
                <li>Совпадает ли с change log? Эффект должен совпадать по времени с изменением</li>
            </ul>
        </div>

        <div class="section">
            <div class="section-title">Куда дальше</div>
            <div class="next-cards">
                <a href="./price-elasticity.html" class="next-card">
                    <div class="next-card-title">Эластичность →</div>
                    <div class="next-card-text">Эластичность и пределы цены.</div>
                </a>
                <a href="../operating/incidents.html" class="next-card">
                    <div class="next-card-title">Эксплуатация системы: инциденты →</div>
                    <div class="next-card-text">Инциденты и диагностика.</div>
                </a>
                <a href="./price-vs-volume.html" class="next-card">
                    <div class="next-card-title">Цена и объём →</div>
                    <div class="next-card-text">Декомпозиция выручки.</div>
                </a>
            </div>
        </div>

        <div class="footer">
            <a href="./index.html" class="back-link">← Назад к Рынку</a>
            <p class="footer-note">Рынок двигается сам. Ваша задача — не принять фон за результат.</p>
        </div>
    </div>

    <script>
        // Seasonality chart
        function generateSeasonalityChart() {
            const container = d3.select('#seasonalityChart').node().parentElement;
            const margin = { top: 20, right: 80, bottom: 40, left: 50 };
            const width = Math.min(container.clientWidth, 800) - margin.left - margin.right;
            const height = 350 - margin.top - margin.bottom;

            d3.select('#seasonalityChart').selectAll('*').remove();

            const svg = d3.select('#seasonalityChart')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Generate data: t=1..210
            const n = 210;
            const data = [];
            for (let t = 1; t <= n; t++) {
                // Demand: cyclical with weekly and monthly patterns
                const weeklyCycle = 0.15 * Math.sin(2 * Math.PI * t / 7);
                const monthlyCycle = 0.10 * Math.sin(2 * Math.PI * t / 30);
                const demand = 0.75 + weeklyCycle + monthlyCycle;

                // CPM follows with slight lag
                const cpmLag = Math.max(0, demand - 0.05);
                const cpm = 0.70 + 0.25 * cpmLag;

                // Volume may be counter-phase or weaker
                const volume = 0.80 + 0.10 * Math.sin(2 * Math.PI * t / 7 - Math.PI / 3);

                // Revenue = CPM * Volume (smoothed)
                const revenue = cpm * volume * 0.95;

                data.push({ t, demand, cpm, volume, revenue });
            }

            const x = d3.scaleLinear()
                .domain([1, n])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0.5, 1.1])
                .range([height, 0]);

            // Vertical lines for week boundaries (every 7 days, sparse)
            for (let w = 7; w <= n; w += 7) {
                if (w % 14 === 0) { // Show every other week
                    g.append('line')
                        .attr('x1', x(w))
                        .attr('x2', x(w))
                        .attr('y1', 0)
                        .attr('y2', height)
                        .attr('stroke', '#e8e8e8')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '2,2');
                }
            }

            // Lines
            const lineDemand = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.demand))
                .curve(d3.curveMonotoneX);

            const lineCPM = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.cpm))
                .curve(d3.curveMonotoneX);

            const lineVolume = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.volume))
                .curve(d3.curveMonotoneX);

            const lineRevenue = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.revenue))
                .curve(d3.curveMonotoneX);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 2)
                .attr('d', lineDemand);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#1f2a37')
                .attr('stroke-width', 2)
                .attr('d', lineCPM);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#999')
                .attr('stroke-width', 2)
                .attr('d', lineVolume);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#666')
                .attr('stroke-width', 2)
                .attr('stroke-dasharray', '3,3')
                .attr('d', lineRevenue);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(6).tickFormat(d => `t${d}`))
                .attr('font-size', '11px')
                .attr('color', '#999');

            g.append('g')
                .call(d3.axisLeft(y).ticks(5))
                .attr('font-size', '11px')
                .attr('color', '#999');

            // Labels
            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].demand) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#ccc')
                .text('demand proxy');

            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].cpm) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#1f2a37')
                .text('CPM index');

            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].volume) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#999')
                .text('Volume index');

            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].revenue) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#666')
                .text('Revenue index');
        }

        // Shock chart
        function generateShockChart() {
            const container = d3.select('#shockChart').node().parentElement;
            const margin = { top: 20, right: 80, bottom: 40, left: 50 };
            const width = Math.min(container.clientWidth, 800) - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            d3.select('#shockChart').selectAll('*').remove();

            const svg = d3.select('#shockChart')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Generate data: t=1..210, shock at t≈120
            const n = 210;
            const shockTime = 120;
            const shockSize = 0.25;
            const data = [];
            for (let t = 1; t <= n; t++) {
                // Baseline demand
                let demand = 0.75;

                // Shock: step up at t=120, then partial recovery
                if (t >= shockTime) {
                    const decay = Math.exp(-(t - shockTime) / 30);
                    demand = 0.75 + shockSize * (0.3 + 0.7 * decay);
                }

                // CPM follows demand
                const cpm = 0.70 + 0.25 * (demand - 0.75);

                data.push({ t, demand, cpm });
            }

            const x = d3.scaleLinear()
                .domain([1, n])
                .range([0, width]);

            const y = d3.scaleLinear()
                .domain([0.65, 1.15])
                .range([height, 0]);

            // Shaded region for shock period
            const shockEnd = Math.min(n, shockTime + 40);
            g.append('rect')
                .attr('x', x(shockTime))
                .attr('y', 0)
                .attr('width', x(shockEnd) - x(shockTime))
                .attr('height', height)
                .attr('fill', '#fff5e6')
                .attr('opacity', 0.5);

            g.append('text')
                .attr('x', (x(shockTime) + x(shockEnd)) / 2)
                .attr('y', height - 10)
                .attr('text-anchor', 'middle')
                .attr('font-size', '11px')
                .attr('fill', '#999')
                .text('период шока');

            // Lines
            const lineDemand = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.demand))
                .curve(d3.curveMonotoneX);

            const lineCPM = d3.line()
                .x(d => x(d.t))
                .y(d => y(d.cpm))
                .curve(d3.curveMonotoneX);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#ccc')
                .attr('stroke-width', 2)
                .attr('d', lineDemand);

            g.append('path')
                .datum(data)
                .attr('fill', 'none')
                .attr('stroke', '#1f2a37')
                .attr('stroke-width', 2)
                .attr('d', lineCPM);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x).ticks(6).tickFormat(d => `t${d}`))
                .attr('font-size', '11px')
                .attr('color', '#999');

            g.append('g')
                .call(d3.axisLeft(y).ticks(5))
                .attr('font-size', '11px')
                .attr('color', '#999');

            // Labels
            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].demand) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#ccc')
                .text('demand proxy');

            g.append('text')
                .attr('x', width - 10)
                .attr('y', y(data[data.length - 1].cpm) + 5)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#1f2a37')
                .text('CPM index');
        }

        // Comparison chart
        function generateComparisonChart() {
            const container = d3.select('#comparisonChart').node().parentElement;
            const margin = { top: 20, right: 20, bottom: 40, left: 60 };
            const width = Math.min(container.clientWidth, 800) - margin.left - margin.right;
            const height = 300 - margin.top - margin.bottom;

            d3.select('#comparisonChart').selectAll('*').remove();

            const svg = d3.select('#comparisonChart')
                .attr('width', width + margin.left + margin.right)
                .attr('height', height + margin.top + margin.bottom);

            const g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Data: naive vs controlled uplift
            const data = [
                { group: 'Naive uplift', value: 0.15 },
                { group: 'Controlled uplift', value: 0.02 }
            ];

            const x = d3.scaleBand()
                .domain(data.map(d => d.group))
                .range([0, width])
                .padding(0.3);

            const y = d3.scaleLinear()
                .domain([-0.05, 0.20])
                .range([height, 0]);

            // Bars
            g.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('x', d => x(d.group))
                .attr('y', d => d.value > 0 ? y(d.value) : y(0))
                .attr('width', x.bandwidth())
                .attr('height', d => Math.abs(y(d.value) - y(0)))
                .attr('fill', (d, i) => i === 0 ? '#999' : '#1f2a37');

            // Zero line
            g.append('line')
                .attr('x1', 0)
                .attr('x2', width)
                .attr('y1', y(0))
                .attr('y2', y(0))
                .attr('stroke', '#ccc')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '2,2');

            // Value labels
            g.selectAll('.value-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'value-label')
                .attr('x', d => x(d.group) + x.bandwidth() / 2)
                .attr('y', d => d.value > 0 ? y(d.value) - 5 : y(d.value) + 18)
                .attr('text-anchor', 'middle')
                .attr('font-size', '11px')
                .attr('fill', '#1a1a1a')
                .text(d => `${(d.value * 100).toFixed(1)}%`);

            // Axes
            g.append('g')
                .attr('transform', `translate(0,${height})`)
                .call(d3.axisBottom(x))
                .attr('font-size', '11px')
                .attr('color', '#999');

            g.append('g')
                .call(d3.axisLeft(y).ticks(5).tickFormat(d3.format('.0%')))
                .attr('font-size', '11px')
                .attr('color', '#999');

            // Y-axis label
            g.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', -45)
                .attr('text-anchor', 'middle')
                .attr('font-size', '11px')
                .attr('fill', '#666')
                .text('uplift');
        }

        // Interactive calculator
        function updateCalculator() {
            const seasonalityEnabled = document.getElementById('seasonalityCheck').checked;
            const seasonalityAmp = parseInt(document.getElementById('seasonalitySlider').value) / 100;
            const shockEnabled = document.getElementById('shockCheck').checked;
            const shockSize = parseInt(document.getElementById('shockSlider').value) / 100;
            const noiseLevel = parseInt(document.getElementById('noiseSlider').value) / 100;
            const metric = document.getElementById('metricSelect').value;

            // Generate synthetic series t=1..210
            const n = 210;
            const shockTime = 120;
            const preStart = 80;
            const preEnd = 115;
            const postStart = 125;
            const postEnd = 160;

            const series = [];
            let preSum = 0;
            let postSum = 0;
            let baselinePostSum = 0;

            for (let t = 1; t <= n; t++) {
                // Baseline = 1 + seasonality + longer wave
                let baseline = 1.0;
                if (seasonalityEnabled) {
                    const weekly = seasonalityAmp * 0.15 * Math.sin(2 * Math.PI * t / 7);
                    const monthly = seasonalityAmp * 0.10 * Math.sin(2 * Math.PI * t / 30);
                    baseline += weekly + monthly;
                }

                // Shock: step at t0 with decay
                let shock = 0;
                if (shockEnabled && t >= shockTime) {
                    const decay = Math.exp(-(t - shockTime) / 30);
                    shock = shockSize * (0.3 + 0.7 * decay);
                }

                // Noise: deterministic pseudo-noise (sum of sines with different periods)
                const noise = noiseLevel * 0.05 * (
                    Math.sin(2 * Math.PI * t / 11) +
                    Math.sin(2 * Math.PI * t / 17) +
                    Math.sin(2 * Math.PI * t / 23)
                ) / 3;

                // Metric series depends on demand
                const demand = baseline + shock + noise;
                let value;
                if (metric === 'CPM') {
                    // CPM ~ demand^(0.6) + constraint-like plateau
                    value = 0.70 + 0.25 * Math.pow(Math.min(1.0, demand - 0.75), 0.6);
                } else if (metric === 'Volume') {
                    // Volume ~ demand*(1 - saturation(demand))
                    const saturation = Math.max(0, (demand - 0.85) * 2);
                    value = 0.80 + 0.15 * demand * (1 - saturation);
                } else { // Revenue
                    const cpm = 0.70 + 0.25 * Math.pow(Math.min(1.0, demand - 0.75), 0.6);
                    const volume = 0.80 + 0.15 * demand * (1 - Math.max(0, (demand - 0.85) * 2));
                    value = cpm * volume * 0.95;
                }

                series.push({ t, value, baseline: baseline });

                // Calculate averages for windows
                if (t >= preStart && t <= preEnd) {
                    preSum += value;
                }
                if (t >= postStart && t <= postEnd) {
                    postSum += value;
                    // Baseline-adjusted: expected value without shock/noise
                    const baselineValue = baseline; // Simplified
                    baselinePostSum += baselineValue;
                }
            }

            const preAvg = preSum / (preEnd - preStart + 1);
            const postAvg = postSum / (postEnd - postStart + 1);
            const baselinePostAvg = baselinePostSum / (postEnd - postStart + 1);

            // Uplifts
            const naiveUplift = (postAvg - preAvg) / preAvg;
            const controlledUplift = (postAvg - baselinePostAvg) / baselinePostAvg;

            // Risk assessment
            let risk = 'low';
            if ((shockEnabled || noiseLevel > 30) && seasonalityEnabled) {
                risk = 'high';
            } else if (shockEnabled || noiseLevel > 15 || seasonalityEnabled) {
                risk = 'medium';
            }

            const riskText = {
                'low': 'Низкий риск ложной атрибуции',
                'medium': 'Средний риск ложной атрибуции',
                'high': 'Высокий риск ложной атрибуции'
            };

            document.getElementById('outputPanel').innerHTML = `
                <div class="output-metric">
                    <div class="output-metric-label">Naive uplift</div>
                    <div class="output-metric-value">${(naiveUplift * 100).toFixed(1)}%</div>
                </div>
                <div class="output-metric">
                    <div class="output-metric-label">Baseline-adjusted uplift</div>
                    <div class="output-metric-value">${(controlledUplift * 100).toFixed(1)}%</div>
                </div>
                <div class="output-risk ${risk}">
                    ${riskText[risk]}
                </div>
            `;
        }

        document.getElementById('seasonalityCheck').addEventListener('change', updateCalculator);
        document.getElementById('seasonalitySlider').addEventListener('input', (e) => {
            document.getElementById('seasonalityValue').textContent = e.target.value;
            updateCalculator();
        });
        document.getElementById('shockCheck').addEventListener('change', updateCalculator);
        document.getElementById('shockSlider').addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            document.getElementById('shockValue').textContent = val >= 0 ? `+${val}` : val;
            updateCalculator();
        });
        document.getElementById('noiseSlider').addEventListener('input', (e) => {
            document.getElementById('noiseValue').textContent = e.target.value;
            updateCalculator();
        });
        document.getElementById('metricSelect').addEventListener('change', updateCalculator);

        // Initial render
        generateSeasonalityChart();
        generateShockChart();
        generateComparisonChart();
        updateCalculator();

        // Responsive resize
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                generateSeasonalityChart();
                generateShockChart();
                generateComparisonChart();
            }, 250);
        });
    </script>
    <script>
        (function () {
            const current = window.location.pathname.replace(/\/$/, "");
            links.forEach(a => {
                const href = a.getAttribute("href");
                if (!href) return;
                const normalized = href.replace(/\/$/, "");
                if (normalized === current || current.endsWith(normalized)) {
                    a.classList.add("active");
                    a.setAttribute("aria-current", "page");
                    const section = a.closest(".nav-section");
                    if (section) section.classList.add("active-section");
                }
            });
        })();
    </script>
</body>
</html>

